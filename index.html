<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AriaCall - recepcjonistka AI w Twoim gabinecie!</title>
  <style>
    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f4f4f4;
      text-align: center;
    }

    h1 {
      font-size: 24px;
      font-weight: bold;
      color: #000;
    }

    #visual {
      margin: 20px 0;
    }

    #ball {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background-color: #B3CBFC;
      margin: 20px auto;
      animation: none;
      transition: transform 0.3s ease-in-out;
    }

    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.3);
      }
    }

    button {
      width: 200px;
      padding: 15px;
      margin: 10px;
      border: none;
      border-radius: 30px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      color: #fff;
      background-color: #4E8AFF;
      transition: background-color 0.3s ease;
    }

    button:disabled {
      background-color: #A9A9A9;
    }

    #output {
      color: #000;
      font-size: 16px;
      margin-top: 20px;
    }

    /* Center the ball and buttons on mobile */
    @media (max-width: 768px) {
      #visual, button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <h1>AriaCall - recepcjonistka AI w Twoim gabinecie!</h1>

  <div id="visual">
    <div id="ball"></div>
  </div>

  <button id="start">Zadzwoń</button>
  <button id="stop" disabled>Zawieś</button>

  <div id="output"></div>

  <script>
    const ws = new WebSocket('ws://localhost:3000/connection');
    let audioContext;
    let microphoneStream;
    let processor;
    let conversationStarted = false;
    let audioQueue = [];
    let isPlaying = false;

    ws.onopen = () => {
      console.log('Connected to server');
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      console.log('Received message from server:', data);

      if (data.event === 'media' && data.media && data.media.payload) {
        audioQueue.push(data.media.payload);
        if (!isPlaying) {
          playNextAudio();
        }
      }

      if (data.partialResponse) {
        document.getElementById('output').innerHTML += `<p>${data.partialResponse}</p>`;
      }
    };

    function playNextAudio() {
      if (audioQueue.length === 0) {
        isPlaying = false;
        console.log("Audio playback finished.");
        animateBall(false); // Stop ball animation
        return;
      }

      isPlaying = true;
      const audioData = audioQueue.shift();
      const audio = new Audio(`data:audio/wav;base64,${audioData}`);
      audio.onended = playNextAudio;
      animateBall(true); // Start ball animation during audio playback
      audio.play().then(() => {
        console.log("Played audio");
      }).catch((error) => {
        console.error("Error playing audio:", error);
        playNextAudio();
      });
    }

    function startMicrophone() {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          microphoneStream = audioContext.createMediaStreamSource(stream);

          processor = audioContext.createScriptProcessor(2048, 1, 1);
          microphoneStream.connect(processor);
          processor.connect(audioContext.destination);

          processor.onaudioprocess = function(e) {
            const inputData = e.inputBuffer.getChannelData(0);
            const downsampledBuffer = downsampleBuffer(inputData, audioContext.sampleRate, 8000);
            const encodedData = encodeMuLaw(downsampledBuffer);
            const base64data = btoa(String.fromCharCode.apply(null, encodedData));

            ws.send(JSON.stringify({
              event: 'media',
              media: { payload: base64data }
            }));
          };

          console.log('Microphone started');
        })
        .catch(err => {
          console.error('Error accessing microphone:', err);
        });
    }

    function stopMicrophone() {
      if (processor) {
        processor.disconnect();
        processor.onaudioprocess = null;
        processor = null;
      }
      if (microphoneStream) {
        microphoneStream.disconnect();
        microphoneStream = null;
      }
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      console.log('Microphone stopped');
    }

    function downsampleBuffer(buffer, sampleRate, outSampleRate) {
      if (outSampleRate === sampleRate) {
        return buffer;
      }
      if (outSampleRate > sampleRate) {
        throw 'Downsampling rate should be smaller than original sample rate';
      }
      const sampleRateRatio = sampleRate / outSampleRate;
      const newLength = Math.round(buffer.length / sampleRateRatio);
      const result = new Float32Array(newLength);
      let offsetResult = 0;
      let offsetBuffer = 0;
      while (offsetResult < result.length) {
        const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
        let accum = 0, count = 0;
        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
          accum += buffer[i];
          count++;
        }
        result[offsetResult] = accum / count;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
      }
      return result;
    }

    function encodeMuLaw(samples) {
      const MULAW_MAX = 0x1FFF;
      const MULAW_BIAS = 33;
      const encoded = new Uint8Array(samples.length);
      for (let i = 0; i < samples.length; i++) {
        let sample = samples[i];
        sample = Math.max(-1, Math.min(1, sample));
        sample = sample * MULAW_MAX;
        let sign = (sample < 0) ? 0x80 : 0;
        sample = Math.abs(sample);
        sample += MULAW_BIAS;
        if (sample > MULAW_MAX) {
          sample = MULAW_MAX;
        }
        let exponent = Math.floor(Math.log(sample) / Math.log(2));
        let mantissa = (sample >> (exponent - 3)) & 0x0F;
        let muLawByte = ~(sign | ((exponent - 5) << 4) | mantissa);
        encoded[i] = muLawByte;
      }
      return encoded;
    }

    function animateBall(start) {
      const ball = document.getElementById('ball');
      if (start) {
        ball.style.animation = 'pulse 1s infinite';
      } else {
        ball.style.animation = 'none';
      }
    }

    document.getElementById('start').addEventListener('click', () => {
      if (conversationStarted) return;

      document.getElementById('start').disabled = true;
      document.getElementById('stop').disabled = false;

      ws.send(JSON.stringify({
        event: 'start',
        message: 'Starting conversation'
      }));
      conversationStarted = true;

      console.log('Started conversation');
      startMicrophone();
    });

    document.getElementById('stop').addEventListener('click', () => {
      if (!conversationStarted) return;

      stopMicrophone();

      document.getElementById('start').disabled = false;
      document.getElementById('stop').disabled = true;

      ws.send(JSON.stringify({
        event: 'stop',
        message: 'Ending conversation'
      }));
      conversationStarted = false;

      console.log('Stopped conversation');
    });
  </script>
</body>
</html>